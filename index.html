<html>
  <head>
    <meta charset="utf-8">

    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" href="client/css/app.css">
  </head>
  <body>
    <div class="wrapper">
      <div id="instructions">
        <div>
          move with <span class="key">wasd</span>, click to attack
          <br />(Dvorak supported)
        </div>
      </div>

      <div id="score"></div>
      <div id="main">
          <div id="canvas-box"></div>
        <div id="chatbox">
          <div id="chatoutput"></div>
          <input type="text" id="chatinput"></input>
          <button id="chatsend">Send</button>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="client/js/resources.js"></script>
    <script type="text/javascript" src="client/js/gl-matrix.js"></script>
    <script id="makeShadows" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        float GetShadowDistanceH() {
            float u = vTexCoord0.x;
            float v = vTexCoord0.y;

            u = abs(u-0.5) * 2.0;
            v = v * 2.0 - 1.0;
            float v0 = v/u;
            v0 = (v0 + 1.0) / 2.0;

            vec4 color = texture2D(uSampler, vec2((vTexCoord0.x<0.5?0.0:1.0) / resolution.x, v0));

            return color.r;
        }

        float GetShadowDistanceV() {
            float u = vTexCoord0.y;
            float v = vTexCoord0.x;

            u = abs(u-0.5) * 2.0;
            v = v * 2.0 - 1.0;
            float v0 = v/u;
            v0 = (v0 + 1.0) / 2.0;

            vec4 color = texture2D(uSampler, vec2((vTexCoord0.y<0.5?0.0:1.0) / resolution.x, v0));

            return color.g;
        }

        void main(void) {
            // distance of this pixel from the center
            float distance = length(vTexCoord0 - vec2(0.5, 0.5));

            //distance stored in the shadow map
            float shadowMapDistance;
            //coords in [-1,1]
            float nY = 2.0*( vTexCoord0.y - 0.5);
            float nX = 2.0*( vTexCoord0.x - 0.5);

            //we use these to determine which quadrant we are in
            if(abs(nY)<abs(nX))
            {
                shadowMapDistance = GetShadowDistanceH();
            }
            else
            {
                shadowMapDistance = GetShadowDistanceV();
            }

            //if distance to this pixel is lower than distance from shadowMap,
            //then we are not in shadow
            float light = distance < shadowMapDistance ? 1.0:0.0;
            //float light = vTexCoord0.x > shadowMapDistance ? 1.0:0.0;
            vec4 result = vec4(light);
            vec2 fracLoc = gl_FragCoord.xy / resolution;
            float len = length(fracLoc - 0.5);
            float invDist = 1.0 - (len * (resolution.x / 300.0));
            invDist = max(0.0, invDist);
            float invDistSq = invDist * invDist;
            result.a = 1.0;
            result.r = min(invDistSq, light);
            result.g = min(invDistSq, light);
            result.b = min(invDistSq, light);
            gl_FragColor = result;
        }
    </script>

    <script id="reduction" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        // width / 2
        uniform float size;

        void main(void) {
            float fractionalSize = size / resolution.x;
            if (vTexCoord0.x <= fractionalSize / 2.0) {
                vec4 color = texture2D(uSampler, vTexCoord0);
                vec4 otherColor = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize / 2.0, vTexCoord0.y));

                float resultRed = min(color.r, otherColor.r);
                float resultGreen = min(color.g, otherColor.g);

                gl_FragColor = vec4(resultRed, resultGreen, 0.0, 1.0);
            } else if (vTexCoord0.x <= fractionalSize) {
                vec4 color = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize / 2.0, vTexCoord0.y));
                vec4 otherColor = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize, vTexCoord0.y));

                float resultRed = min(color.r, otherColor.r);
                float resultGreen = min(color.g, otherColor.g);

                gl_FragColor = vec4(resultRed, resultGreen, 0.0, 1.0);
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        }
    </script>

    <script id="distance" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            vec4 color = texture2D(uSampler, vTexCoord0);
            if ((color.r < 0.9 || color.g < 0.9 || color.b < 0.9) && color.a > 0.1) {
                float distance = length(vTexCoord0 - 0.5) + (2.0 / resolution.x);
                gl_FragColor = vec4(0.0,0.0,0.0, distance);
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        }
    </script>

    <script id="test" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            //translate u and v into [-1 , 1] domain
            float u0 = vTexCoord0.x * 2.0 - 1.0;
            float v0 = vTexCoord0.y * 2.0 - 1.0;

            //then, as u0 approaches 0 (the center), v should also approach 0
            float u1 = u0 * abs(v0);
            float v1 = v0 * abs(u0);
            //convert back from [-1,1] domain to [0,1] domain
            u1 = (u1 + 1.0) / 2.0;
            v1 = (v1 + 1.0) / 2.0;

            //read for both horizontal and vertical direction and store them in separate channels

            float horizontal = texture2D(uSampler, vec2(vTexCoord0.x, v1)).a;
            float vertical = texture2D(uSampler, vec2(v1, vTexCoord0.x)).a;

            gl_FragColor = vec4(horizontal, vertical, 0.0, 1.0);
        }
    </script>

    <script id="allOrNothing" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;

        void main(void) {
            vec4 fragC = texture2D(uSampler, vTexCoord0);
            if (fragC.a > 0.3 && (fragC.r < 0.9 || fragC.g < 0.9 || fragC.b < 0.9)) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
        }
    </script>

    <script id="transparent" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            vec4 color = texture2D(uSampler, vTexCoord0);
            if (color.a > 0.3 && (color.r < 0.9 || color.g < 0.9 || color.b < 0.9)) {
                float distance = 1.0 - (length(vTexCoord0 - 0.5) * (resolution.x / 300.0));
                distance = max(0.0, distance);
                color.r = color.r * distance;
                color.g = color.g * distance;
                color.b = color.b * distance;
                gl_FragColor = color;
            } else {
                gl_FragColor = vec4(0.0);
            }
        }
    </script>

    <script id="gaussian-horizontal" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler; // the texture with the scene you want to blur
        uniform vec2 resolution;

        void main(void)
        {
           vec4 sum = vec4(0.0);

           float distance = length(vTexCoord0 - 0.5);
           float blurSize = (20.0 * (distance)) / resolution.x;

           // blur in x (horizontal)
           // take nine samples, with the distance blurSize between them
           sum += texture2D(uSampler, vec2(vTexCoord0.x - 4.0*blurSize, vTexCoord0.y)) * 0.05;
           sum += texture2D(uSampler, vec2(vTexCoord0.x - 3.0*blurSize, vTexCoord0.y)) * 0.09;
           sum += texture2D(uSampler, vec2(vTexCoord0.x - 2.0*blurSize, vTexCoord0.y)) * 0.12;
           sum += texture2D(uSampler, vec2(vTexCoord0.x - blurSize, vTexCoord0.y)) * 0.15;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y)) * 0.16;
           sum += texture2D(uSampler, vec2(vTexCoord0.x + blurSize, vTexCoord0.y)) * 0.15;
           sum += texture2D(uSampler, vec2(vTexCoord0.x + 2.0*blurSize, vTexCoord0.y)) * 0.12;
           sum += texture2D(uSampler, vec2(vTexCoord0.x + 3.0*blurSize, vTexCoord0.y)) * 0.09;
           sum += texture2D(uSampler, vec2(vTexCoord0.x + 4.0*blurSize, vTexCoord0.y)) * 0.05;

           gl_FragColor = sum;
        }
    </script>

    <script id="gaussian-vertical" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler; // this should hold the texture rendered by the horizontal blur pass
        uniform vec2 resolution;

        void main(void)
        {
           vec4 sum = vec4(0.0);

           float distance = length(vTexCoord0 - 0.5) / sqrt(2.0);
           float blurSize = (20.0 * (distance)) / resolution.x;

           // blur in y (vertical)
           // take nine samples, with the distance blurSize between them
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y - 4.0*blurSize)) * 0.05;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y - 3.0*blurSize)) * 0.09;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y - 2.0*blurSize)) * 0.12;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y - blurSize)) * 0.15;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y)) * 0.16;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y + blurSize)) * 0.15;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y + 2.0*blurSize)) * 0.12;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y + 3.0*blurSize)) * 0.09;
           sum += texture2D(uSampler, vec2(vTexCoord0.x, vTexCoord0.y + 4.0*blurSize)) * 0.05;

           gl_FragColor = sum;
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            gl_FragColor = texture2D(uSampler, vec2(vTexCoord0.s, vTexCoord0.t));
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTexCoord0;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTexCoord0 = aTextureCoord;
        }
    </script>
    <script type="text/javascript" src="client/js/webgl.js"></script>
    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
