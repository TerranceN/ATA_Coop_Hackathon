<html>
  <head>
    <meta charset="utf-8">

    <title></title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" href="client/css/app.css">
  </head>
  <body>
    <div class="wrapper">
      <div id="instructions">
        <div>
          move with <span class="key">wasd</span>, click to attack
          <br />(Dvorak supported)
        </div>
      </div>

      <div id="score"></div>
      <div id="main">
          <div id="canvas-box"><canvas id="canvas"></canvas></div>
        <div id="chatbox">
          <div id="chatoutput"></div>
          <input type="text" id="chatinput"></input>
          <button id="chatsend">Send</button>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="client/js/resources.js"></script>
    <script type="text/javascript" src="http://learningwebgl.com/lessons/lesson05/glMatrix-0.9.5.min.js"></script>
    <script type="text/javascript" src="http://learningwebgl.com/lessons/lesson05/webgl-utils.js"></script>
    <script id="makeShadows" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;
        uniform vec2 mousePos;

        float GetShadowDistanceH() {
            float u = vTexCoord0.x;
            float v = vTexCoord0.y;

            u = abs(u-0.5) * 2.0;
            v = v * 2.0 - 1.0;
            float v0 = v/u;
            v0 = (v0 + 1.0) / 2.0;

            vec4 color = texture2D(uSampler, vec2((vTexCoord0.x<0.5?0.0:1.0) / resolution.x, v0));

            return color.r;
        }

        float GetShadowDistanceV() {
            float u = vTexCoord0.y;
            float v = vTexCoord0.x;

            u = abs(u-0.5) * 2.0;
            v = v * 2.0 - 1.0;
            float v0 = v/u;
            v0 = (v0 + 1.0) / 2.0;

            vec4 color = texture2D(uSampler, vec2((vTexCoord0.y<0.5?0.0:1.0) / resolution.x, v0));

            return color.g;
        }

        void main(void) {
            // distance of this pixel from the center
            float distance = length(vTexCoord0 - vec2(0.5, 0.5));

            //distance stored in the shadow map
            float shadowMapDistance;
            //coords in [-1,1]
            float nY = 2.0*( vTexCoord0.y - 0.5);
            float nX = 2.0*( vTexCoord0.x - 0.5);

            //we use these to determine which quadrant we are in
            if(abs(nY)<abs(nX))
            {
                shadowMapDistance = GetShadowDistanceH();
            }
            else
            {
                shadowMapDistance = GetShadowDistanceV();
            }

            //if distance to this pixel is lower than distance from shadowMap,
            //then we are not in shadow
            float light = distance < shadowMapDistance ? 1.0:0.0;
            //float light = vTexCoord0.x > shadowMapDistance ? 1.0:0.0;
            vec4 result = vec4(light);
            result.a = 1.0;
            gl_FragColor = result;
        }
    </script>

    <script id="reduction" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        // width / 2
        uniform float size;

        void main(void) {
            float fractionalSize = size / resolution.x;
            if (vTexCoord0.x <= fractionalSize / 2.0) {
                vec4 color = texture2D(uSampler, vTexCoord0);
                vec4 otherColor = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize / 2.0, vTexCoord0.y));

                float resultRed = min(color.r, otherColor.r);
                float resultGreen = min(color.g, otherColor.g);

                gl_FragColor = vec4(resultRed, resultGreen, 0.0, 1.0);
            } else if (vTexCoord0.x <= fractionalSize) {
                vec4 color = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize / 2.0, vTexCoord0.y));
                vec4 otherColor = texture2D(uSampler, vec2(vTexCoord0.x + fractionalSize, vTexCoord0.y));

                float resultRed = min(color.r, otherColor.r);
                float resultGreen = min(color.g, otherColor.g);

                gl_FragColor = vec4(resultRed, resultGreen, 0.0, 1.0);
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        }
    </script>

    <script id="distance" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            vec4 color = texture2D(uSampler, vTexCoord0);
            if (color.a > 0.1) {
                float distance = length(vTexCoord0 - 0.5);
                gl_FragColor = vec4(0.0,0.0,0.0, distance);
            } else {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
            //compute distance from center
            //save it to the Red channel
        }
    </script>

    <script id="test" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            //translate u and v into [-1 , 1] domain
            float u0 = vTexCoord0.x * 2.0 - 1.0;
            float v0 = vTexCoord0.y * 2.0 - 1.0;

            //then, as u0 approaches 0 (the center), v should also approach 0
            float u1 = u0 * abs(v0);
            float v1 = v0 * abs(u0);
            //convert back from [-1,1] domain to [0,1] domain
            u1 = (u1 + 1.0) / 2.0;
            v1 = (v1 + 1.0) / 2.0;

            //read for both horizontal and vertical direction and store them in separate channels

            float horizontal = texture2D(uSampler, vec2(vTexCoord0.x, v1)).a;
            float vertical = texture2D(uSampler, vec2(v1, vTexCoord0.x)).a;

            gl_FragColor = vec4(horizontal, vertical, 0.0, 1.0);
        }
    </script>

    <script id="allOrNothing" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;

        void main(void) {
            vec4 fragC = texture2D(uSampler, vec2(vTexCoord0.s, vTexCoord0.t));
            if (fragC.a > 0.3) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
        }
    </script>

    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;

        varying vec2 vTexCoord0;

        uniform sampler2D uSampler;
        uniform vec2 resolution;

        void main(void) {
            gl_FragColor = texture2D(uSampler, vec2(vTexCoord0.s, vTexCoord0.t));
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec2 aTextureCoord;
        attribute vec4 aColor;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec2 vTexCoord0;
        varying vec4 vColor;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            vTexCoord0 = aTextureCoord;
            vColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
    </script>
    <script type="text/javascript" src="client/js/webgl.js"></script>
    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
